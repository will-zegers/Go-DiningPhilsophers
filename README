For details on individual functions, view the docs in main.go, philospher.go, and fork.go

This solution to the Dining Philosophers problem uses a combination of channels, mutexes, and conditional variables - implemented in the Go language - to manage resource access andp prevent concurrency hazards such as deadlocks and race conditions.

The description of each concurrency tool is as follows:
	- ForkMutex: This is a conditional variablea used to build a monitor that ensure that a philospher can pick up both forks without being preempted; that is, he can't pick up his left fork, lose his timeslice, and come back to find that his neighbor had nabbed his right-hand fork during that time. Preemption can still happen, but ForkMutex ensures that only one philospher is allowed to pick up forks. If his left-hand fork is not there (i.e., the channel is empty), the philosopher goes into a wait state, giving up the lock and sleeping until he is signalled. This signal is generated on the call to ReplaceForks(), whereby another philosopher puts his forks back (refills the channel) and signals to any waiting philosophers that the resources may be once again available. The first philospher wakes back up, attempts to re-acquire the lock and, if successful, rechecks his left-hand fork channel. If the channel is empty, he will once again return to a wait state and repeat the previous part.

If the left-hand fork is available, he will next go to grab the right-hand fork. If this fork is unavailable, he will will block while still holding the lock, ensuring that forks can only be replaced but never acquired by another philosopher. The point of this is, were the right hand fork available, the philospher can not be preempted in the moment between grabbing the left fork and right fork by his neighbor. Without this, there is the (highly unlikely, but nonetheless possible) case that each philosopher could preempt the other at the same moment each time, whereby each philospher will hold a single fork and cause to deadlock. Once the philsopher has both forks, he reales the lock and returns from the GetForks function. Other philosphers, who may or may not be blocking on the mutex on line 68, are now free to go after their forks.

Since the mutex only protects the act of picking up the forks and nothing else, it's still possible for two philosopher to eat concurrently as well as replace their forks when they're done.

	- randMutex: This mutex simply protects the call to generate a random number, ensuring that only one Eat() or Think() function at a time has access to read from the random number generator. This generator is used for randomizing the eating and thinking duration for each philosopher.

The forks and philsophers are represented by indexing their respective arrays, making iterating philosphers - as well as matching them up to corresponding forks - straight forward. Philosopher i's left-hand fork is at index i of the Forks array, and his right-hand fork is at index i + 1 mod 4. The Forks array itself contains a 1-deep buffer of boolean values at each index. Forks are "picked up" by taking a value out of the channel, and replaced by putting a "true" (though the value doesn't matter) back in. An empty channel will block, implying the fork is already in use.

Each philopher is represented as a Goroutine, spawned in the main function (with the main function eventually taking on the role of philosopher 0 after it has spawned all the others). Each thread runs indefinitely, cycling through Think -> GetForks -> Eat -> ReplaceForks -> Think -> ... and so on.
